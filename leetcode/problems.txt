Key Categories to Practice
Here’s where 80% of the questions will likely come from:
Arrays & Strings


Sliding window, two pointers, prefix sums.


Hashing


Counting, maps, sets (anagrams, frequency).


Stacks & Queues


Valid parentheses, monotonic stack, min stack.


Recursion & Backtracking


Subsets, permutations, DFS problems.


Binary Search & Sorting


Search variants, rotated array, quickselect.


Graphs (BFS/DFS)


Shortest path, connected components.


Dynamic Programming (light)


Fibonacci, climbing stairs, house robber.



🔥 10 Intermediate+ Practice Problems (in JavaScript)
Two Sum II – Input Array is Sorted
 Given a sorted array, return indices of two numbers that add up to a target.
 Pattern: Two pointers.


Longest Substring Without Repeating Characters
 Find length of longest substring without duplicates.
 Pattern: Sliding window + HashSet.


Valid Parentheses
 Check if a string containing only ()[]{} is valid.
 Pattern: Stack.


Group Anagrams
 Given an array of strings, group anagrams together.
 Pattern: HashMap with sorted string as key.


Maximum Subarray (Kadane’s Algorithm)
 Find the contiguous subarray with the largest sum.
 Pattern: Dynamic Programming / greedy.


Product of Array Except Self
 Given nums, return array where each element is product of all except itself.
 Pattern: Prefix + suffix product arrays.


Search in Rotated Sorted Array
 Return index of target in rotated sorted array.
 Pattern: Modified binary search.


Top K Frequent Elements
 Find k most frequent elements in an array.
 Pattern: HashMap + Min Heap or sorting.


Number of Islands
 Given 2D grid of ‘1’s and ‘0’s, count islands.
 Pattern: DFS/BFS flood fill.


Coin Change
 Given coins [1,2,5] and amount 11, return fewest coins.
 Pattern: Dynamic Programming.



📍 How to Practice (2-day crash prep)
Day 1: Arrays, Strings, Hashing, Stacks/Queues.


Day 2: Graphs, Binary Search, DP (light).


Practice writing code in JS without IDE autocompletion — just like the live environment.


For each, first talk through your thought process out loud, then code, then test edge cases.



👉 I can give you concise JS template solutions for each of the above so you can practice quickly without spending hours debugging syntax.
 Do you want me to draft those ready-to-run snippets for all 10 problems?
You said:
Yes
ChatGPT said:
Great — let’s get you battle-ready, Ian 💪.
 Below are ready-to-run JavaScript template solutions for the 10 key problems. Each one is commented so you can practice explaining while coding (very important for live interviews).

1. Two Sum II – Input Array is Sorted
function twoSum(numbers, target) {
  let left = 0, right = numbers.length - 1;
  while (left < right) {
    const sum = numbers[left] + numbers[right];
    if (sum === target) return [left, right];
    if (sum < target) left++;
    else right--;
  }
  return [];
}

// Example
console.log(twoSum([2,7,11,15], 9)); // [0,1]


2. Longest Substring Without Repeating Characters
function lengthOfLongestSubstring(s) {
  let set = new Set();
  let left = 0, maxLen = 0;
  
  for (let right = 0; right < s.length; right++) {
    while (set.has(s[right])) {
      set.delete(s[left]);
      left++;
    }
    set.add(s[right]);
    maxLen = Math.max(maxLen, right - left + 1);
  }
  return maxLen;
}

console.log(lengthOfLongestSubstring("abcabcbb")); // 3


3. Valid Parentheses
function isValid(s) {
  const stack = [];
  const map = {')':'(', ']':'[', '}':'{'};
  
  for (let ch of s) {
    if (ch === '(' || ch === '[' || ch === '{') stack.push(ch);
    else if (!stack.length || stack.pop() !== map[ch]) return false;
  }
  
  return stack.length === 0;
}

console.log(isValid("()[]{}")); // true


4. Group Anagrams
function groupAnagrams(strs) {
  const map = new Map();
  
  for (let str of strs) {
    const key = str.split('').sort().join('');
    if (!map.has(key)) map.set(key, []);
    map.get(key).push(str);
  }
  
  return Array.from(map.values());
}

console.log(groupAnagrams(["eat","tea","tan","ate","nat","bat"]));


5. Maximum Subarray (Kadane’s)
function maxSubArray(nums) {
  let curr = nums[0], max = nums[0];
  for (let i = 1; i < nums.length; i++) {
    curr = Math.max(nums[i], curr + nums[i]);
    max = Math.max(max, curr);
  }
  return max;
}

console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4])); // 6


6. Product of Array Except Self
function productExceptSelf(nums) {
  const res = Array(nums.length).fill(1);
  let prefix = 1, suffix = 1;
  
  for (let i = 0; i < nums.length; i++) {
    res[i] = prefix;
    prefix *= nums[i];
  }
  for (let i = nums.length - 1; i >= 0; i--) {
    res[i] *= suffix;
    suffix *= nums[i];
  }
  return res;
}

console.log(productExceptSelf([1,2,3,4])); // [24,12,8,6]


7. Search in Rotated Sorted Array
function search(nums, target) {
  let left = 0, right = nums.length - 1;
  
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    
    if (nums[mid] === target) return mid;
    
    if (nums[left] <= nums[mid]) { 
      if (target >= nums[left] && target < nums[mid]) right = mid - 1;
      else left = mid + 1;
    } else { 
      if (target > nums[mid] && target <= nums[right]) left = mid + 1;
      else right = mid - 1;
    }
  }
  return -1;
}

console.log(search([4,5,6,7,0,1,2], 0)); // 4


8. Top K Frequent Elements
function topKFrequent(nums, k) {
  const map = new Map();
  for (let n of nums) map.set(n, (map.get(n) || 0) + 1);
  
  const bucket = [];
  for (let [num, freq] of map) {
    if (!bucket[freq]) bucket[freq] = [];
    bucket[freq].push(num);
  }
  
  const res = [];
  for (let i = bucket.length - 1; i >= 0 && res.length < k; i--) {
    if (bucket[i]) res.push(...bucket[i]);
  }
  return res;
}

console.log(topKFrequent([1,1,1,2,2,3], 2)); // [1,2]


9. Number of Islands
function numIslands(grid) {
  if (!grid.length) return 0;
  let count = 0;
  
  function dfs(r,c) {
    if (r<0 || c<0 || r>=grid.length || c>=grid[0].length || grid[r][c] === '0') return;
    grid[r][c] = '0'; // mark visited
    dfs(r+1,c); dfs(r-1,c); dfs(r,c+1); dfs(r,c-1);
  }
  
  for (let r=0; r<grid.length; r++) {
    for (let c=0; c<grid[0].length; c++) {
      if (grid[r][c] === '1') {
        count++;
        dfs(r,c);
      }
    }
  }
  return count;
}

console.log(numIslands([
  ["1","1","0","0"],
  ["1","0","0","1"],
  ["0","0","1","1"]
])); // 3


10. Coin Change
function coinChange(coins, amount) {
  const dp = Array(amount+1).fill(Infinity);
  dp[0] = 0;
  
  for (let coin of coins) {
    for (let i=coin; i<=amount; i++) {
      dp[i] = Math.min(dp[i], dp[i-coin] + 1);
    }
  }
  
  return dp[amount] === Infinity ? -1 : dp[amount];
}

console.log(coinChange([1,2,5], 11)); // 3


⚡ Strategy for next 2 days:
Solve 5 problems each day (timed: 20–25 min each).


For each:


Explain your plan out loud before coding.


Write code.


Dry-run on sample input.


State time/space complexity.
